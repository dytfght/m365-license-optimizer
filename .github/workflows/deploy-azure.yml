name: ðŸš€ Deploy M365 License Optimizer (Bicep)

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  AZURE_RESOURCE_GROUP: m365-optimizer-prod
  AZURE_LOCATION: francecentral
  POSTGRES_SERVER_NAME: m365optimizerdb
  POSTGRES_DATABASE_NAME: m365_optimizer
  POSTGRES_ADMIN_USER: adminuser
  REDIS_CACHE_NAME: m365optimizerredis
  ACR_NAME: m365optimizeracr
  WEBAPP_BACKEND_NAME: m365-optimizer-backend
  APP_SERVICE_PLAN: m365-optimizer-plan

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Create Resource Group
        run: |
          az group create \
            --name ${{ env.AZURE_RESOURCE_GROUP }} \
            --location ${{ env.AZURE_LOCATION }}

      # DÃ©ploiement Infrastructure via Bicep
      - name: Deploy Infrastructure (Bicep)
        uses: azure/arm-deploy@v1
        with:
          subscriptionId: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          resourceGroupName: ${{ env.AZURE_RESOURCE_GROUP }}
          template: ./Main.bicep
          parameters: >
            postgresServerName=${{ env.POSTGRES_SERVER_NAME }}
            postgresDbName=${{ env.POSTGRES_DATABASE_NAME }}
            postgresAdminUser=${{ env.POSTGRES_ADMIN_USER }}
            postgresAdminPassword=${{ secrets.POSTGRES_ADMIN_PASSWORD }}
            redisName=${{ env.REDIS_CACHE_NAME }}
            acrName=${{ env.ACR_NAME }}
            appServicePlanName=${{ env.APP_SERVICE_PLAN }}
            webAppName=${{ env.WEBAPP_BACKEND_NAME }}

      # Build & Push Docker Images
      - name: Login to ACR
        run: az acr login --name ${{ env.ACR_NAME }}

      - name: Build & Push Backend Image
        run: |
          docker build \
            -f backend/Dockerfile \
            -t ${{ env.ACR_NAME }}.azurecr.io/m365-backend:${{ github.sha }} \
            -t ${{ env.ACR_NAME }}.azurecr.io/m365-backend:latest \
            backend
          
          docker push ${{ env.ACR_NAME }}.azurecr.io/m365-backend:${{ github.sha }}
          docker push ${{ env.ACR_NAME }}.azurecr.io/m365-backend:latest

      # âœ… CORRECTION: Initialisation DB via Alembic (pas init.sql)
      - name: Database Migration (Alembic)
        env:
          PGPASSWORD: ${{ secrets.POSTGRES_ADMIN_PASSWORD }}
          PGSSLMODE: require
        run: |
          # Installation PostgreSQL client
          sudo apt-get update && sudo apt-get install -y postgresql-client python3-pip
          
          # Installation Alembic et dÃ©pendances
          pip install alembic asyncpg sqlalchemy pydantic pydantic-settings
          
          # Ajout IP Runner temporaire au firewall
          RUNNER_IP=$(curl -s https://api.ipify.org)
          echo "ðŸ”“ Adding runner IP: $RUNNER_IP"
          
          az postgres flexible-server firewall-rule create \
            -g ${{ env.AZURE_RESOURCE_GROUP }} \
            -n ${{ env.POSTGRES_SERVER_NAME }} \
            --rule-name github-runner-temp \
            --start-ip-address $RUNNER_IP \
            --end-ip-address $RUNNER_IP
          
          # Attente propagation firewall
          sleep 15
          
          # âœ… VÃ©rifier si le schÃ©ma optimizer existe
          SCHEMA_EXISTS=$(psql \
            -h ${{ env.POSTGRES_SERVER_NAME }}.postgres.database.azure.com \
            -U ${{ env.POSTGRES_ADMIN_USER }} \
            -d ${{ env.POSTGRES_DATABASE_NAME }} \
            -tAc "SELECT EXISTS(SELECT 1 FROM information_schema.schemata WHERE schema_name='optimizer')" \
            || echo "false")
          
          if [ "$SCHEMA_EXISTS" = "t" ]; then
            echo "âœ… Schema 'optimizer' exists"
          else
            echo "ðŸ†• Creating schema 'optimizer' for first deployment"
            psql \
              -h ${{ env.POSTGRES_SERVER_NAME }}.postgres.database.azure.com \
              -U ${{ env.POSTGRES_ADMIN_USER }} \
              -d ${{ env.POSTGRES_DATABASE_NAME }} \
              -c "CREATE SCHEMA IF NOT EXISTS optimizer;"
          fi
          
          # âœ… Appliquer les migrations Alembic
          echo "ðŸ”„ Running Alembic migrations..."
          cd backend
          
          export DATABASE_URL="postgresql+asyncpg://${{ env.POSTGRES_ADMIN_USER }}:${{ secrets.POSTGRES_ADMIN_PASSWORD }}@${{ env.POSTGRES_SERVER_NAME }}.postgres.database.azure.com:5432/${{ env.POSTGRES_DATABASE_NAME }}?ssl=require"
          
          alembic upgrade head
          
          # VÃ©rifier l'Ã©tat des migrations
          CURRENT_VERSION=$(psql \
            -h ${{ env.POSTGRES_SERVER_NAME }}.postgres.database.azure.com \
            -U ${{ env.POSTGRES_ADMIN_USER }} \
            -d ${{ env.POSTGRES_DATABASE_NAME }} \
            -tAc "SELECT version_num FROM alembic_version" \
            || echo "none")
          
          echo "âœ… Database migrated to version: $CURRENT_VERSION"
          
          # Afficher les tables crÃ©Ã©es
          echo "ðŸ“Š Tables in optimizer schema:"
          psql \
            -h ${{ env.POSTGRES_SERVER_NAME }}.postgres.database.azure.com \
            -U ${{ env.POSTGRES_ADMIN_USER }} \
            -d ${{ env.POSTGRES_DATABASE_NAME }} \
            -c "SELECT tablename FROM pg_tables WHERE schemaname='optimizer' ORDER BY tablename;"
          
          # Nettoyage firewall
          az postgres flexible-server firewall-rule delete \
            -g ${{ env.AZURE_RESOURCE_GROUP }} \
            -n ${{ env.POSTGRES_SERVER_NAME }} \
            --rule-name github-runner-temp \
            --yes

      # Configuration App Service
      - name: Configure Web App Settings
        run: |
          az webapp config appsettings set \
            -g ${{ env.AZURE_RESOURCE_GROUP }} \
            -n ${{ env.WEBAPP_BACKEND_NAME }} \
            --settings \
              DATABASE_URL="postgresql+asyncpg://${{ env.POSTGRES_ADMIN_USER }}:${{ secrets.POSTGRES_ADMIN_PASSWORD }}@${{ env.POSTGRES_SERVER_NAME }}.postgres.database.azure.com:5432/${{ env.POSTGRES_DATABASE_NAME }}?ssl=require" \
              REDIS_URL="rediss://:${{ secrets.REDIS_PASSWORD }}@${{ env.REDIS_CACHE_NAME }}.redis.cache.windows.net:6380/0" \
              JWT_SECRET_KEY="${{ secrets.JWT_SECRET_KEY }}" \
              AZURE_AD_TENANT_ID="${{ secrets.AZURE_AD_TENANT_ID }}" \
              AZURE_AD_CLIENT_ID="${{ secrets.AZURE_AD_CLIENT_ID }}" \
              AZURE_AD_CLIENT_SECRET="${{ secrets.AZURE_AD_CLIENT_SECRET }}" \
              ENVIRONMENT="production"

      # DÃ©ploiement de l'image Docker
      - name: Deploy to Azure Web App
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ env.WEBAPP_BACKEND_NAME }}
          images: ${{ env.ACR_NAME }}.azurecr.io/m365-backend:${{ github.sha }}

      - name: Restart Web App
        run: |
          az webapp restart \
            -g ${{ env.AZURE_RESOURCE_GROUP }} \
            -n ${{ env.WEBAPP_BACKEND_NAME }}

      - name: Output Deployment URLs
        run: |
          echo "=================================================="
          echo "ðŸš€ DÃ‰PLOIEMENT RÃ‰USSI"
          echo "=================================================="
          echo "Backend API : https://${{ env.WEBAPP_BACKEND_NAME }}.azurewebsites.net"
          echo "Swagger Docs: https://${{ env.WEBAPP_BACKEND_NAME }}.azurewebsites.net/docs"
          echo "Health Check: https://${{ env.WEBAPP_BACKEND_NAME }}.azurewebsites.net/health"
          echo "=================================================="
          echo "Database: ${{ env.POSTGRES_SERVER_NAME }}.postgres.database.azure.com"
          echo "Redis   : ${{ env.REDIS_CACHE_NAME }}.redis.cache.windows.net"
          echo "=================================================="
