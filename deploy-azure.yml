name: üöÄ Deploy M365 License Optimizer (Bicep)

on:
  push:
    branches: [ main, lot2 ]
  workflow_dispatch:

env:
  AZURE_RESOURCE_GROUP: m365-optimizer-dev
  AZURE_LOCATION: francecentral
  # Ces variables sont pass√©es au fichier Bicep
  POSTGRES_SERVER_NAME: m365optimizerdb
  POSTGRES_DATABASE_NAME: m365_optimizer
  POSTGRES_ADMIN_USER: adminuser
  REDIS_CACHE_NAME: m365optimizerredis
  ACR_NAME: m365optimizeracr
  WEBAPP_BACKEND_NAME: m365-optimizer-backend
  APP_SERVICE_PLAN: m365-optimizer-plan

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Create Resource Group
        run: az group create --name ${{ env.AZURE_RESOURCE_GROUP }} --location ${{ env.AZURE_LOCATION }}

      # √âTAPE CL√â : D√©ploiement de l'Infrastructure via Bicep
      - name: Deploy Infrastructure (Bicep)
        uses: azure/arm-deploy@v1
        with:
          subscriptionId: ${{ secrets.AZURE_SUBSCRIPTION_ID }} # Assurez-vous d'avoir l'ID dans vos secrets ou hardcod√©
          resourceGroupName: ${{ env.AZURE_RESOURCE_GROUP }}
          template: ./main.bicep # Assurez-vous que le fichier est √† la racine
          parameters: >
            postgresServerName=${{ env.POSTGRES_SERVER_NAME }}
            postgresDbName=${{ env.POSTGRES_DATABASE_NAME }}
            postgresAdminUser=${{ env.POSTGRES_ADMIN_USER }}
            postgresAdminPassword=${{ secrets.POSTGRES_ADMIN_PASSWORD }}
            redisName=${{ env.REDIS_CACHE_NAME }}
            acrName=${{ env.ACR_NAME }}
            appServicePlanName=${{ env.APP_SERVICE_PLAN }}
            webAppName=${{ env.WEBAPP_BACKEND_NAME }}

      # Build & Push Docker (L'infra est pr√™te, l'ACR existe gr√¢ce √† l'√©tape pr√©c√©dente)
      - name: Login to ACR
        run: az acr login --name ${{ env.ACR_NAME }}

      - name: Build & Push Backend Image
        run: |
          docker build -f backend/Dockerfile -t ${{ env.ACR_NAME }}.azurecr.io/m365-optimizer-backend:latest .
          docker push ${{ env.ACR_NAME }}.azurecr.io/m365-optimizer-backend:latest

      # Initialisation DB (Toujours n√©cessaire en script)
      - name: DB Initialization (Firewall & SQL)
        env:
          PGPASSWORD: ${{ secrets.POSTGRES_ADMIN_PASSWORD }}
        run: |
          sudo apt-get update && sudo apt-get install -y postgresql-client
          
          # Ajout IP Runner temporaire (Bicep g√®re mal les IP dynamiques car cela cr√©erait un diff permanent)
          IP=$(curl -s https://api.ipify.org)
          echo "Adding Runner IP: $IP"
          az postgres flexible-server firewall-rule create -g ${{ env.AZURE_RESOURCE_GROUP }} -n ${{ env.POSTGRES_SERVER_NAME }} --rule-name GitHubRunner --start-ip-address $IP --end-ip-address $IP

          # Wait for firewall propagation
          sleep 10

          # Run SQL script
          psql -h ${{ env.POSTGRES_SERVER_NAME }}.postgres.database.azure.com \
               -U ${{ env.POSTGRES_ADMIN_USER }} \
               -d ${{ env.POSTGRES_DATABASE_NAME }} \
               -f docker/db/init.sql
               
          # Nettoyage de la r√®gle firewall (Bonne pratique)
          az postgres flexible-server firewall-rule delete -g ${{ env.AZURE_RESOURCE_GROUP }} -n ${{ env.POSTGRES_SERVER_NAME }} --rule-name GitHubRunner --yes

      # Restart WebApp pour prendre la nouvelle image
      - name: Restart Web App
        run: az webapp restart -g ${{ env.AZURE_RESOURCE_GROUP }} -n ${{ env.WEBAPP_BACKEND_NAME }}

      - name: Output URLs
        run: |
          echo "Backend : https://${{ env.WEBAPP_BACKEND_NAME }}.azurewebsites.net"